import heapq

class PuzzleState:
    def __init__(self, board, parent=None, move="", depth=0, cost=0):
        self.board = board
        self.parent = parent
        self.move = move
        self.depth = depth
        self.cost = cost  # f(n) = g(n) + h(n)

    def __lt__(self, other):
        return self.cost < other.cost

    def get_blank_position(self):
        return self.board.index(0)

    def generate_moves(self):
        moves = []
        pos = self.get_blank_position()
        row, col = divmod(pos, 3)

        directions = {
            "Up": (row - 1, col),
            "Down": (row + 1, col),
            "Left": (row, col - 1),
            "Right": (row, col + 1)
        }

        for move, (r, c) in directions.items():
            if 0 <= r < 3 and 0 <= c < 3:
                new_pos = r * 3 + c
                new_board = self.board[:]
                new_board[pos], new_board[new_pos] = new_board[new_pos], new_board[pos]
                moves.append(PuzzleState(new_board, self, move, self.depth + 1))
        return moves

def manhattan_distance(board, goal):
    distance = 0
    for i, tile in enumerate(board):
        if tile != 0:
            goal_pos = goal.index(tile)
            x1, y1 = divmod(i, 3)
            x2, y2 = divmod(goal_pos, 3)
            distance += abs(x1 - x2) + abs(y1 - y2)
    return distance

def solve_puzzle(start, goal):
    open_list = []
    visited = set()

    start_state = PuzzleState(start, None, "", 0, manhattan_distance(start, goal))
    heapq.heappush(open_list, start_state)

    while open_list:
        current = heapq.heappop(open_list)

        if current.board == goal:
            moves = []
            while current.parent:
                moves.append(current.move)
                current = current.parent
            return moves[::-1]

        visited.add(tuple(current.board))

        for neighbor in current.generate_moves():
            if tuple(neighbor.board) not in visited:
                neighbor.cost = neighbor.depth + manhattan_distance(neighbor.board, goal)
                heapq.heappush(open_list, neighbor)

    return None

# Example usage
start_state = [1, 2, 3,
               4, 0, 5,
               7, 8, 6]

goal_state = [1, 2, 3,
              4, 5, 6,
              7, 8, 0]

solution = solve_puzzle(start_state, goal_state)

if solution:
    print("Solution found in", len(solution), "moves:", solution)
else:
    print("No solution exists.")
